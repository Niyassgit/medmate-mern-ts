import { UnautharizedError } from "../../../domain/common/errors";
import { ISubscriptionRepositoy } from "../../../domain/subscription/repositories/ISubscriptionRepository";
import { ErrorMessages } from "../../../shared/Messages";
import { CreateSubscriptionDTO } from "../dto/CreateSubscriptionDTO";
import { SubscriptionDTO } from "../dto/SubscriptionDTO";
import { ICreateSubscriptionPlanUseCase } from "../interfaces/ICreateSubscriptionPlanUseCase";
import { SubscriptionMapper } from "../mappers/SubscriptionMapper";

export class CreateSubscriptionPlanUseCase implements ICreateSubscriptionPlanUseCase {
  constructor(private _subscriptionRepository: ISubscriptionRepositoy) {}
  async execute(dto: CreateSubscriptionDTO, userId?: string): Promise<SubscriptionDTO> {
    if (!userId) throw new UnautharizedError(ErrorMessages.UNAUTHORIZED);
    
    // Convert DTO to domain entity (features are IDs at this point)
    const mappedPlan = SubscriptionMapper.toEntity(dto);
    
    // Create a complete ISubscription entity for repository
    // Note: id, createdAt, updatedAt, isActive will be set by database
    const subscriptionEntity: ISubscription = {
      id: "", // Will be generated by database
      ...mappedPlan,
      isActive: true, // Default to active
      createdAt: new Date(), // Will be overwritten by database
      updatedAt: new Date(), // Will be overwritten by database
    };
    
    const result = await this._subscriptionRepository.createSubscription(
      subscriptionEntity
    );
    if (!result) throw new Error(ErrorMessages.SUB_CREATE_ERROR);
    return SubscriptionMapper.toDomain(result);
  }
}
 